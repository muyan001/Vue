<!-- 

    事件修饰符：
        在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。
        尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。

        为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。

        .stop
            阻止单击事件继续传播
            <a v-on:click.stop="doThis"></a>

        .prevent
            提交事件不再重载页面
            <form v-on:submit.prevent="onSubmit"></form>

            

        .capture

        .self
        .once
        .passive

        修饰符可以串联
            <a v-on:click.stop.prevent="doThat"></a>
        
        只有修饰符
            <form v-on:submit.prevent></form>

        添加事件监听器时使用事件捕获模式
        即内部元素触发的事件先在此处理，然后才交由内部元素进行处理
            <div v-on:click.capture="doThis">...</div>

        只当在 event.target 是当前元素自身时触发处理函数，即事件不是从内部元素触发的
            <div v-on:click.self="doThat">...</div>


    使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。
        因此，用v-on:click.prevent.self 会阻止所有的点击，
        而 v-on:click.self.prevent 只会阻止对元素自身的点击。





 -->


<html>
    <head>
        <script src="vue.js"></script>
    </head>
    <body>
        <div id="app">
            <div id="example1">
                <button v-on:click="count += 2">数值：{{count}}</button>
                <!-- $event  有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法 -->
                <button v-on:click = "test('abc',$event)">test</button>
            </div>
        </div>
        <script>
            var vm = new Vue({
                el:"#example1",
                data:{
                    count:0,
                    name:"hah"
                },
                methods:{
                    test:function(str,e){
                        alert(123);
                        // 拿到data内部的数据,,注意要加this
                        // `this` 在方法里指向当前 Vue 实例
                        alert(this.name);
                        alert(this.count);
                        alert(str);
                        console.log(e);

                    }
                }
            });
        </script>
    </body>
</html>